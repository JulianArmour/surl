import sqlite3

from flask import url_for
from flask_restful import Resource, reqparse, inputs

from smurl import shortener
from smurl.db import get_db

parser = reqparse.RequestParser()
parser.add_argument("original_url", type=inputs.url, required=True, trim=True)
parser.add_argument("short_str", trim=True)


class UrlMap(Resource):
    @staticmethod
    def post():
        args = parser.parse_args(strict=True)

        if args["short_str"]:
            try:
                short_str = create_custom(args["original_url"], args["short_str"])
            except sqlite3.IntegrityError:
                return "This shortened url is already taken.", 409
        else:
            short_str = create_autogenerated(args["original_url"])

        return {
            "_links": {
                "short_url": url_for(
                    "shortener.redirect_short", short_hash=short_str, _external=True
                )
            },
            "original_url": args["original_url"],
            "short_str": short_str,
        }


def create_autogenerated(original_url):
    db = get_db()
    c = db.cursor()
    # The next generated short hash may be taken by a custom url. Keep trying until
    # a free hash is found.
    while True:
        c.execute("INSERT INTO HashIdGen DEFAULT VALUES")
        db.commit()
        new_id = c.lastrowid
        id_hash = shortener.hash_from_id(new_id)
        try:
            c.execute(
                "INSERT INTO UrlMap (original_url, short_hash) VALUES (?,?)",
                (original_url, id_hash),
            )
            db.commit()
            break
        except sqlite3.IntegrityError:
            continue
    return id_hash


def create_custom(original_url, short_str):
    db = get_db()
    db.execute(
        "INSERT INTO UrlMap(original_url, short_hash) VALUES (?,?)",
        (original_url, short_str),
    )
    db.commit()
    return short_str
